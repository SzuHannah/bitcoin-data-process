# Algorithms

### Weighted Quick Union with Path Compression (WQUPC)

The address clustering algorithm can be implemented with WQUPC, described in Table 1, and the walletID assignment steps following the clustering result are illustrated in Table 2. Scripts and a python notebook example can be found [here](https://github.com/SzuHannah/bitcoin-data-process/tree/main/csvToWallet).&#x20;

| Table 1 WQUPC Algorithm                                                                                                                                                                                                                                                                                                                                                                                                                |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>Input requirements:  </p><p>(i) An edge list that recorded addresses that were ever spent together such that we could read in the edge list to do the Union operation (e.g. if address 1 and address 2 were spent together, we will do Union(1,2))  </p><p>(ii) A list that recorded the parent of each node, and a list that recorded the rank of each node </p><p>Note: p in the following procedure means parent</p>             |
| <p>def Make-Set(x): </p><p>    x.p=x </p><p>    x.rank=0 </p><p></p><p>def Union(x,y): </p><p>&emsp Link(Find-Set(x),Find-Set(y)) </p><p></p><p>def Link(x,y):</p><p>    if x.rank > y.rank </p><p>        y.p=x </p><p>    else x.p=y </p><p>        if x.rank == y.rank </p><p>        y.rank = y.rank+1 </p><p></p><p>def Find-Set(x) </p><p>        if x != x.p </p><p>            x.p = Find-Set(x.p) </p><p>        return x.p</p> |

| Table 2 Steps of assigning wallet IDs to addresses                                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>Input requirements:</p><p>(i) An edge list that records addresses that were ever spent together </p><p>(ii) The parent record resulted from the WQUPC Algorithm</p>                                        |
| <p>Step 1: read in edge list and run WQUPC algorithm on all addresses </p><p>Step 2: Use the parent record to find the root for each address </p><p>Step 3: Export the root as wallet ID for each address</p> |

### Approximated Personalized PageRank (PPR)

One way to study entities' transaction behavior is through investigating upstream/downstream critical wallets for those famous wallets in the transaction network. This is equivalent to finding vertices that are most relevant to a specific node in a graph. This kind of problem setup is one of the applications for Personalized PageRank (PPR). As the bitcoin transaction network is large, and running PPR on the whole graph would be inefficient, we adopted a faster modification of PPR, the approximate PPR algorithm[^1], to solve the problem.

| Table 3 Approximate Personalized PageRank Algorithm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Input requirement: undirected graph G, PPR vector $$p \in [0,1]^{N}$$, preference vector ùúã, teleportation constant ùõº, and tolerance ùúÄ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <p><strong>Initialize </strong><span class="math">p \leftarrow 0</span>, <span class="math"> r \leftarrow \pi</span>, <span class="math"> \alpha' \leftarrow \alpha/(2-\alpha)</span></p><p><strong>while </strong><span class="math">\exists u \in V</span>such that <span class="math">r_{u} \geq \epsilon d_{u}</span> <strong>do</strong></p><p>    uniformly sample a vertex u satisfying <span class="math">r_{u} \geq \epsilon d_{u}</span></p><p>        <span class="math">p_{u} \leftarrow p_{u} + \alpha' r_{u}</span></p><p>    <strong>for</strong> <span class="math">v:(u,v) \in E</span> do</p><p>        <span class="math">r_{u} \leftarrow r_{v} + (1-\alpha')r_{u}/2d_{u}</span>‚Äã</p><p>    <strong>end for</strong></p><p>        <span class="math">r_{u} \leftarrow (1-\alpha')r_{u}/2</span></p><p><strong>end while</strong></p><p><strong>return</strong> <span class="math">\epsilon-</span>approximate PPR vector <span class="math">p</span>‚Äã</p> |

[^1]: Chen, F., Zhang, Y. and Rohe, K. (2020), Targeted sampling from massive block model graphs with personalized PageRank. J. R. Stat. Soc. B, 82: 99-126. https://doi.org/10.1111/rssb.12349
